// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATASCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_METADATASCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct AssociatedFile;
struct AssociatedFileBuilder;

struct FeatureProperties;
struct FeaturePropertiesBuilder;

struct ImageSize;
struct ImageSizeBuilder;

struct ImageProperties;
struct ImagePropertiesBuilder;

struct AudioProperties;
struct AudioPropertiesBuilder;

struct BoundingBoxProperties;
struct BoundingBoxPropertiesBuilder;

struct ValueRange;
struct ValueRangeBuilder;

struct Content;
struct ContentBuilder;

struct NormalizationOptions;
struct NormalizationOptionsBuilder;

struct ScoreCalibrationOptions;
struct ScoreCalibrationOptionsBuilder;

struct ScoreThresholdingOptions;
struct ScoreThresholdingOptionsBuilder;

struct BertTokenizerOptions;
struct BertTokenizerOptionsBuilder;

struct SentencePieceTokenizerOptions;
struct SentencePieceTokenizerOptionsBuilder;

struct RegexTokenizerOptions;
struct RegexTokenizerOptionsBuilder;

struct ProcessUnit;
struct ProcessUnitBuilder;

struct Stats;
struct StatsBuilder;

struct TensorGroup;
struct TensorGroupBuilder;

struct TensorMetadata;
struct TensorMetadataBuilder;

struct CustomMetadata;
struct CustomMetadataBuilder;

struct SubGraphMetadata;
struct SubGraphMetadataBuilder;

struct ModelMetadata;
struct ModelMetadataBuilder;

enum AssociatedFileType : int8_t {
  AssociatedFileType_UNKNOWN = 0,
  AssociatedFileType_DESCRIPTIONS = 1,
  AssociatedFileType_TENSOR_AXIS_LABELS = 2,
  AssociatedFileType_TENSOR_VALUE_LABELS = 3,
  AssociatedFileType_TENSOR_AXIS_SCORE_CALIBRATION = 4,
  AssociatedFileType_VOCABULARY = 5,
  AssociatedFileType_SCANN_INDEX_FILE = 6,
  AssociatedFileType_MIN = AssociatedFileType_UNKNOWN,
  AssociatedFileType_MAX = AssociatedFileType_SCANN_INDEX_FILE
};

inline const AssociatedFileType (&EnumValuesAssociatedFileType())[7] {
  static const AssociatedFileType values[] = {
    AssociatedFileType_UNKNOWN,
    AssociatedFileType_DESCRIPTIONS,
    AssociatedFileType_TENSOR_AXIS_LABELS,
    AssociatedFileType_TENSOR_VALUE_LABELS,
    AssociatedFileType_TENSOR_AXIS_SCORE_CALIBRATION,
    AssociatedFileType_VOCABULARY,
    AssociatedFileType_SCANN_INDEX_FILE
  };
  return values;
}

inline const char * const *EnumNamesAssociatedFileType() {
  static const char * const names[8] = {
    "UNKNOWN",
    "DESCRIPTIONS",
    "TENSOR_AXIS_LABELS",
    "TENSOR_VALUE_LABELS",
    "TENSOR_AXIS_SCORE_CALIBRATION",
    "VOCABULARY",
    "SCANN_INDEX_FILE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssociatedFileType(AssociatedFileType e) {
  if (::flatbuffers::IsOutRange(e, AssociatedFileType_UNKNOWN, AssociatedFileType_SCANN_INDEX_FILE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssociatedFileType()[index];
}

enum ColorSpaceType : int8_t {
  ColorSpaceType_UNKNOWN = 0,
  ColorSpaceType_RGB = 1,
  ColorSpaceType_GRAYSCALE = 2,
  ColorSpaceType_MIN = ColorSpaceType_UNKNOWN,
  ColorSpaceType_MAX = ColorSpaceType_GRAYSCALE
};

inline const ColorSpaceType (&EnumValuesColorSpaceType())[3] {
  static const ColorSpaceType values[] = {
    ColorSpaceType_UNKNOWN,
    ColorSpaceType_RGB,
    ColorSpaceType_GRAYSCALE
  };
  return values;
}

inline const char * const *EnumNamesColorSpaceType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "RGB",
    "GRAYSCALE",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorSpaceType(ColorSpaceType e) {
  if (::flatbuffers::IsOutRange(e, ColorSpaceType_UNKNOWN, ColorSpaceType_GRAYSCALE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorSpaceType()[index];
}

enum BoundingBoxType : int8_t {
  BoundingBoxType_UNKNOWN = 0,
  BoundingBoxType_BOUNDARIES = 1,
  BoundingBoxType_UPPER_LEFT = 2,
  BoundingBoxType_CENTER = 3,
  BoundingBoxType_MIN = BoundingBoxType_UNKNOWN,
  BoundingBoxType_MAX = BoundingBoxType_CENTER
};

inline const BoundingBoxType (&EnumValuesBoundingBoxType())[4] {
  static const BoundingBoxType values[] = {
    BoundingBoxType_UNKNOWN,
    BoundingBoxType_BOUNDARIES,
    BoundingBoxType_UPPER_LEFT,
    BoundingBoxType_CENTER
  };
  return values;
}

inline const char * const *EnumNamesBoundingBoxType() {
  static const char * const names[5] = {
    "UNKNOWN",
    "BOUNDARIES",
    "UPPER_LEFT",
    "CENTER",
    nullptr
  };
  return names;
}

inline const char *EnumNameBoundingBoxType(BoundingBoxType e) {
  if (::flatbuffers::IsOutRange(e, BoundingBoxType_UNKNOWN, BoundingBoxType_CENTER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBoundingBoxType()[index];
}

enum CoordinateType : int8_t {
  CoordinateType_RATIO = 0,
  CoordinateType_PIXEL = 1,
  CoordinateType_MIN = CoordinateType_RATIO,
  CoordinateType_MAX = CoordinateType_PIXEL
};

inline const CoordinateType (&EnumValuesCoordinateType())[2] {
  static const CoordinateType values[] = {
    CoordinateType_RATIO,
    CoordinateType_PIXEL
  };
  return values;
}

inline const char * const *EnumNamesCoordinateType() {
  static const char * const names[3] = {
    "RATIO",
    "PIXEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateType(CoordinateType e) {
  if (::flatbuffers::IsOutRange(e, CoordinateType_RATIO, CoordinateType_PIXEL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateType()[index];
}

enum ContentProperties : uint8_t {
  ContentProperties_NONE = 0,
  ContentProperties_FeatureProperties = 1,
  ContentProperties_ImageProperties = 2,
  ContentProperties_BoundingBoxProperties = 3,
  ContentProperties_AudioProperties = 4,
  ContentProperties_MIN = ContentProperties_NONE,
  ContentProperties_MAX = ContentProperties_AudioProperties
};

inline const ContentProperties (&EnumValuesContentProperties())[5] {
  static const ContentProperties values[] = {
    ContentProperties_NONE,
    ContentProperties_FeatureProperties,
    ContentProperties_ImageProperties,
    ContentProperties_BoundingBoxProperties,
    ContentProperties_AudioProperties
  };
  return values;
}

inline const char * const *EnumNamesContentProperties() {
  static const char * const names[6] = {
    "NONE",
    "FeatureProperties",
    "ImageProperties",
    "BoundingBoxProperties",
    "AudioProperties",
    nullptr
  };
  return names;
}

inline const char *EnumNameContentProperties(ContentProperties e) {
  if (::flatbuffers::IsOutRange(e, ContentProperties_NONE, ContentProperties_AudioProperties)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesContentProperties()[index];
}

template<typename T> struct ContentPropertiesTraits {
  static const ContentProperties enum_value = ContentProperties_NONE;
};

template<> struct ContentPropertiesTraits<tflite::FeatureProperties> {
  static const ContentProperties enum_value = ContentProperties_FeatureProperties;
};

template<> struct ContentPropertiesTraits<tflite::ImageProperties> {
  static const ContentProperties enum_value = ContentProperties_ImageProperties;
};

template<> struct ContentPropertiesTraits<tflite::BoundingBoxProperties> {
  static const ContentProperties enum_value = ContentProperties_BoundingBoxProperties;
};

template<> struct ContentPropertiesTraits<tflite::AudioProperties> {
  static const ContentProperties enum_value = ContentProperties_AudioProperties;
};

bool VerifyContentProperties(::flatbuffers::Verifier &verifier, const void *obj, ContentProperties type);
bool VerifyContentPropertiesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ScoreTransformationType : int8_t {
  ScoreTransformationType_IDENTITY = 0,
  ScoreTransformationType_LOG = 1,
  ScoreTransformationType_INVERSE_LOGISTIC = 2,
  ScoreTransformationType_MIN = ScoreTransformationType_IDENTITY,
  ScoreTransformationType_MAX = ScoreTransformationType_INVERSE_LOGISTIC
};

inline const ScoreTransformationType (&EnumValuesScoreTransformationType())[3] {
  static const ScoreTransformationType values[] = {
    ScoreTransformationType_IDENTITY,
    ScoreTransformationType_LOG,
    ScoreTransformationType_INVERSE_LOGISTIC
  };
  return values;
}

inline const char * const *EnumNamesScoreTransformationType() {
  static const char * const names[4] = {
    "IDENTITY",
    "LOG",
    "INVERSE_LOGISTIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameScoreTransformationType(ScoreTransformationType e) {
  if (::flatbuffers::IsOutRange(e, ScoreTransformationType_IDENTITY, ScoreTransformationType_INVERSE_LOGISTIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScoreTransformationType()[index];
}

enum ProcessUnitOptions : uint8_t {
  ProcessUnitOptions_NONE = 0,
  ProcessUnitOptions_NormalizationOptions = 1,
  ProcessUnitOptions_ScoreCalibrationOptions = 2,
  ProcessUnitOptions_ScoreThresholdingOptions = 3,
  ProcessUnitOptions_BertTokenizerOptions = 4,
  ProcessUnitOptions_SentencePieceTokenizerOptions = 5,
  ProcessUnitOptions_RegexTokenizerOptions = 6,
  ProcessUnitOptions_MIN = ProcessUnitOptions_NONE,
  ProcessUnitOptions_MAX = ProcessUnitOptions_RegexTokenizerOptions
};

inline const ProcessUnitOptions (&EnumValuesProcessUnitOptions())[7] {
  static const ProcessUnitOptions values[] = {
    ProcessUnitOptions_NONE,
    ProcessUnitOptions_NormalizationOptions,
    ProcessUnitOptions_ScoreCalibrationOptions,
    ProcessUnitOptions_ScoreThresholdingOptions,
    ProcessUnitOptions_BertTokenizerOptions,
    ProcessUnitOptions_SentencePieceTokenizerOptions,
    ProcessUnitOptions_RegexTokenizerOptions
  };
  return values;
}

inline const char * const *EnumNamesProcessUnitOptions() {
  static const char * const names[8] = {
    "NONE",
    "NormalizationOptions",
    "ScoreCalibrationOptions",
    "ScoreThresholdingOptions",
    "BertTokenizerOptions",
    "SentencePieceTokenizerOptions",
    "RegexTokenizerOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessUnitOptions(ProcessUnitOptions e) {
  if (::flatbuffers::IsOutRange(e, ProcessUnitOptions_NONE, ProcessUnitOptions_RegexTokenizerOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProcessUnitOptions()[index];
}

template<typename T> struct ProcessUnitOptionsTraits {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_NONE;
};

template<> struct ProcessUnitOptionsTraits<tflite::NormalizationOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_NormalizationOptions;
};

template<> struct ProcessUnitOptionsTraits<tflite::ScoreCalibrationOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_ScoreCalibrationOptions;
};

template<> struct ProcessUnitOptionsTraits<tflite::ScoreThresholdingOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_ScoreThresholdingOptions;
};

template<> struct ProcessUnitOptionsTraits<tflite::BertTokenizerOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_BertTokenizerOptions;
};

template<> struct ProcessUnitOptionsTraits<tflite::SentencePieceTokenizerOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_SentencePieceTokenizerOptions;
};

template<> struct ProcessUnitOptionsTraits<tflite::RegexTokenizerOptions> {
  static const ProcessUnitOptions enum_value = ProcessUnitOptions_RegexTokenizerOptions;
};

bool VerifyProcessUnitOptions(::flatbuffers::Verifier &verifier, const void *obj, ProcessUnitOptions type);
bool VerifyProcessUnitOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct AssociatedFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AssociatedFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_TYPE = 8,
    VT_LOCALE = 10,
    VT_VERSION = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  tflite::AssociatedFileType type() const {
    return static_cast<tflite::AssociatedFileType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *locale() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALE);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.VerifyString(locale()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
};

struct AssociatedFileBuilder {
  typedef AssociatedFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AssociatedFile::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(AssociatedFile::VT_DESCRIPTION, description);
  }
  void add_type(tflite::AssociatedFileType type) {
    fbb_.AddElement<int8_t>(AssociatedFile::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_locale(::flatbuffers::Offset<::flatbuffers::String> locale) {
    fbb_.AddOffset(AssociatedFile::VT_LOCALE, locale);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(AssociatedFile::VT_VERSION, version);
  }
  explicit AssociatedFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AssociatedFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AssociatedFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AssociatedFile> CreateAssociatedFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    tflite::AssociatedFileType type = tflite::AssociatedFileType_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> locale = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0) {
  AssociatedFileBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_locale(locale);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AssociatedFile> CreateAssociatedFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    tflite::AssociatedFileType type = tflite::AssociatedFileType_UNKNOWN,
    const char *locale = nullptr,
    const char *version = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto locale__ = locale ? _fbb.CreateString(locale) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return tflite::CreateAssociatedFile(
      _fbb,
      name__,
      description__,
      type,
      locale__,
      version__);
}

struct FeatureProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FeaturePropertiesBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FeaturePropertiesBuilder {
  typedef FeatureProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FeaturePropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FeatureProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FeatureProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FeatureProperties> CreateFeatureProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FeaturePropertiesBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ImageSize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageSizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6
  };
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct ImageSizeBuilder {
  typedef ImageSize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ImageSize::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ImageSize::VT_HEIGHT, height, 0);
  }
  explicit ImageSizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageSize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageSize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageSize> CreateImageSize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t width = 0,
    uint32_t height = 0) {
  ImageSizeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct ImageProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImagePropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR_SPACE = 4,
    VT_DEFAULT_SIZE = 6
  };
  tflite::ColorSpaceType color_space() const {
    return static_cast<tflite::ColorSpaceType>(GetField<int8_t>(VT_COLOR_SPACE, 0));
  }
  const tflite::ImageSize *default_size() const {
    return GetPointer<const tflite::ImageSize *>(VT_DEFAULT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COLOR_SPACE, 1) &&
           VerifyOffset(verifier, VT_DEFAULT_SIZE) &&
           verifier.VerifyTable(default_size()) &&
           verifier.EndTable();
  }
};

struct ImagePropertiesBuilder {
  typedef ImageProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color_space(tflite::ColorSpaceType color_space) {
    fbb_.AddElement<int8_t>(ImageProperties::VT_COLOR_SPACE, static_cast<int8_t>(color_space), 0);
  }
  void add_default_size(::flatbuffers::Offset<tflite::ImageSize> default_size) {
    fbb_.AddOffset(ImageProperties::VT_DEFAULT_SIZE, default_size);
  }
  explicit ImagePropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageProperties> CreateImageProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ColorSpaceType color_space = tflite::ColorSpaceType_UNKNOWN,
    ::flatbuffers::Offset<tflite::ImageSize> default_size = 0) {
  ImagePropertiesBuilder builder_(_fbb);
  builder_.add_default_size(default_size);
  builder_.add_color_space(color_space);
  return builder_.Finish();
}

struct AudioProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLE_RATE = 4,
    VT_CHANNELS = 6
  };
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 0);
  }
  uint32_t channels() const {
    return GetField<uint32_t>(VT_CHANNELS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHANNELS, 4) &&
           verifier.EndTable();
  }
};

struct AudioPropertiesBuilder {
  typedef AudioProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioProperties::VT_SAMPLE_RATE, sample_rate, 0);
  }
  void add_channels(uint32_t channels) {
    fbb_.AddElement<uint32_t>(AudioProperties::VT_CHANNELS, channels, 0);
  }
  explicit AudioPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioProperties> CreateAudioProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sample_rate = 0,
    uint32_t channels = 0) {
  AudioPropertiesBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_sample_rate(sample_rate);
  return builder_.Finish();
}

struct BoundingBoxProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoundingBoxPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_TYPE = 6,
    VT_COORDINATE_TYPE = 8
  };
  const ::flatbuffers::Vector<uint32_t> *index() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INDEX);
  }
  tflite::BoundingBoxType type() const {
    return static_cast<tflite::BoundingBoxType>(GetField<int8_t>(VT_TYPE, 0));
  }
  tflite::CoordinateType coordinate_type() const {
    return static_cast<tflite::CoordinateType>(GetField<int8_t>(VT_COORDINATE_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_COORDINATE_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct BoundingBoxPropertiesBuilder {
  typedef BoundingBoxProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> index) {
    fbb_.AddOffset(BoundingBoxProperties::VT_INDEX, index);
  }
  void add_type(tflite::BoundingBoxType type) {
    fbb_.AddElement<int8_t>(BoundingBoxProperties::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_coordinate_type(tflite::CoordinateType coordinate_type) {
    fbb_.AddElement<int8_t>(BoundingBoxProperties::VT_COORDINATE_TYPE, static_cast<int8_t>(coordinate_type), 0);
  }
  explicit BoundingBoxPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoundingBoxProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoundingBoxProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoundingBoxProperties> CreateBoundingBoxProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> index = 0,
    tflite::BoundingBoxType type = tflite::BoundingBoxType_UNKNOWN,
    tflite::CoordinateType coordinate_type = tflite::CoordinateType_RATIO) {
  BoundingBoxPropertiesBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_coordinate_type(coordinate_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoundingBoxProperties> CreateBoundingBoxPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *index = nullptr,
    tflite::BoundingBoxType type = tflite::BoundingBoxType_UNKNOWN,
    tflite::CoordinateType coordinate_type = tflite::CoordinateType_RATIO) {
  auto index__ = index ? _fbb.CreateVector<uint32_t>(*index) : 0;
  return tflite::CreateBoundingBoxProperties(
      _fbb,
      index__,
      type,
      coordinate_type);
}

struct ValueRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6
  };
  int32_t min() const {
    return GetField<int32_t>(VT_MIN, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX, 4) &&
           verifier.EndTable();
  }
};

struct ValueRangeBuilder {
  typedef ValueRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int32_t min) {
    fbb_.AddElement<int32_t>(ValueRange::VT_MIN, min, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(ValueRange::VT_MAX, max, 0);
  }
  explicit ValueRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueRange> CreateValueRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0) {
  ValueRangeBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct Content FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_PROPERTIES_TYPE = 4,
    VT_CONTENT_PROPERTIES = 6,
    VT_RANGE = 8
  };
  tflite::ContentProperties content_properties_type() const {
    return static_cast<tflite::ContentProperties>(GetField<uint8_t>(VT_CONTENT_PROPERTIES_TYPE, 0));
  }
  const void *content_properties() const {
    return GetPointer<const void *>(VT_CONTENT_PROPERTIES);
  }
  template<typename T> const T *content_properties_as() const;
  const tflite::FeatureProperties *content_properties_as_FeatureProperties() const {
    return content_properties_type() == tflite::ContentProperties_FeatureProperties ? static_cast<const tflite::FeatureProperties *>(content_properties()) : nullptr;
  }
  const tflite::ImageProperties *content_properties_as_ImageProperties() const {
    return content_properties_type() == tflite::ContentProperties_ImageProperties ? static_cast<const tflite::ImageProperties *>(content_properties()) : nullptr;
  }
  const tflite::BoundingBoxProperties *content_properties_as_BoundingBoxProperties() const {
    return content_properties_type() == tflite::ContentProperties_BoundingBoxProperties ? static_cast<const tflite::BoundingBoxProperties *>(content_properties()) : nullptr;
  }
  const tflite::AudioProperties *content_properties_as_AudioProperties() const {
    return content_properties_type() == tflite::ContentProperties_AudioProperties ? static_cast<const tflite::AudioProperties *>(content_properties()) : nullptr;
  }
  const tflite::ValueRange *range() const {
    return GetPointer<const tflite::ValueRange *>(VT_RANGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_PROPERTIES_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT_PROPERTIES) &&
           VerifyContentProperties(verifier, content_properties(), content_properties_type()) &&
           VerifyOffset(verifier, VT_RANGE) &&
           verifier.VerifyTable(range()) &&
           verifier.EndTable();
  }
};

template<> inline const tflite::FeatureProperties *Content::content_properties_as<tflite::FeatureProperties>() const {
  return content_properties_as_FeatureProperties();
}

template<> inline const tflite::ImageProperties *Content::content_properties_as<tflite::ImageProperties>() const {
  return content_properties_as_ImageProperties();
}

template<> inline const tflite::BoundingBoxProperties *Content::content_properties_as<tflite::BoundingBoxProperties>() const {
  return content_properties_as_BoundingBoxProperties();
}

template<> inline const tflite::AudioProperties *Content::content_properties_as<tflite::AudioProperties>() const {
  return content_properties_as_AudioProperties();
}

struct ContentBuilder {
  typedef Content Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_properties_type(tflite::ContentProperties content_properties_type) {
    fbb_.AddElement<uint8_t>(Content::VT_CONTENT_PROPERTIES_TYPE, static_cast<uint8_t>(content_properties_type), 0);
  }
  void add_content_properties(::flatbuffers::Offset<void> content_properties) {
    fbb_.AddOffset(Content::VT_CONTENT_PROPERTIES, content_properties);
  }
  void add_range(::flatbuffers::Offset<tflite::ValueRange> range) {
    fbb_.AddOffset(Content::VT_RANGE, range);
  }
  explicit ContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Content> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Content>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Content> CreateContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ContentProperties content_properties_type = tflite::ContentProperties_NONE,
    ::flatbuffers::Offset<void> content_properties = 0,
    ::flatbuffers::Offset<tflite::ValueRange> range = 0) {
  ContentBuilder builder_(_fbb);
  builder_.add_range(range);
  builder_.add_content_properties(content_properties);
  builder_.add_content_properties_type(content_properties_type);
  return builder_.Finish();
}

struct NormalizationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormalizationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN = 4,
    VT_STD = 6
  };
  const ::flatbuffers::Vector<float> *mean() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MEAN);
  }
  const ::flatbuffers::Vector<float> *std() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_STD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyVector(mean()) &&
           VerifyOffset(verifier, VT_STD) &&
           verifier.VerifyVector(std()) &&
           verifier.EndTable();
  }
};

struct NormalizationOptionsBuilder {
  typedef NormalizationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mean(::flatbuffers::Offset<::flatbuffers::Vector<float>> mean) {
    fbb_.AddOffset(NormalizationOptions::VT_MEAN, mean);
  }
  void add_std(::flatbuffers::Offset<::flatbuffers::Vector<float>> std) {
    fbb_.AddOffset(NormalizationOptions::VT_STD, std);
  }
  explicit NormalizationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NormalizationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NormalizationOptions> CreateNormalizationOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> mean = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> std = 0) {
  NormalizationOptionsBuilder builder_(_fbb);
  builder_.add_std(std);
  builder_.add_mean(mean);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NormalizationOptions> CreateNormalizationOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *mean = nullptr,
    const std::vector<float> *std = nullptr) {
  auto mean__ = mean ? _fbb.CreateVector<float>(*mean) : 0;
  auto std__ = std ? _fbb.CreateVector<float>(*std) : 0;
  return tflite::CreateNormalizationOptions(
      _fbb,
      mean__,
      std__);
}

struct ScoreCalibrationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScoreCalibrationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCORE_TRANSFORMATION = 4,
    VT_DEFAULT_SCORE = 6
  };
  tflite::ScoreTransformationType score_transformation() const {
    return static_cast<tflite::ScoreTransformationType>(GetField<int8_t>(VT_SCORE_TRANSFORMATION, 0));
  }
  float default_score() const {
    return GetField<float>(VT_DEFAULT_SCORE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SCORE_TRANSFORMATION, 1) &&
           VerifyField<float>(verifier, VT_DEFAULT_SCORE, 4) &&
           verifier.EndTable();
  }
};

struct ScoreCalibrationOptionsBuilder {
  typedef ScoreCalibrationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_score_transformation(tflite::ScoreTransformationType score_transformation) {
    fbb_.AddElement<int8_t>(ScoreCalibrationOptions::VT_SCORE_TRANSFORMATION, static_cast<int8_t>(score_transformation), 0);
  }
  void add_default_score(float default_score) {
    fbb_.AddElement<float>(ScoreCalibrationOptions::VT_DEFAULT_SCORE, default_score, 0.0f);
  }
  explicit ScoreCalibrationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScoreCalibrationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScoreCalibrationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScoreCalibrationOptions> CreateScoreCalibrationOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ScoreTransformationType score_transformation = tflite::ScoreTransformationType_IDENTITY,
    float default_score = 0.0f) {
  ScoreCalibrationOptionsBuilder builder_(_fbb);
  builder_.add_default_score(default_score);
  builder_.add_score_transformation(score_transformation);
  return builder_.Finish();
}

struct ScoreThresholdingOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScoreThresholdingOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GLOBAL_SCORE_THRESHOLD = 4
  };
  float global_score_threshold() const {
    return GetField<float>(VT_GLOBAL_SCORE_THRESHOLD, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GLOBAL_SCORE_THRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct ScoreThresholdingOptionsBuilder {
  typedef ScoreThresholdingOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_global_score_threshold(float global_score_threshold) {
    fbb_.AddElement<float>(ScoreThresholdingOptions::VT_GLOBAL_SCORE_THRESHOLD, global_score_threshold, 0.0f);
  }
  explicit ScoreThresholdingOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScoreThresholdingOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScoreThresholdingOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScoreThresholdingOptions> CreateScoreThresholdingOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float global_score_threshold = 0.0f) {
  ScoreThresholdingOptionsBuilder builder_(_fbb);
  builder_.add_global_score_threshold(global_score_threshold);
  return builder_.Finish();
}

struct BertTokenizerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BertTokenizerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOCAB_FILE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_VOCAB_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VOCAB_FILE) &&
           verifier.VerifyVector(vocab_file()) &&
           verifier.VerifyVectorOfTables(vocab_file()) &&
           verifier.EndTable();
  }
};

struct BertTokenizerOptionsBuilder {
  typedef BertTokenizerOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vocab_file(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file) {
    fbb_.AddOffset(BertTokenizerOptions::VT_VOCAB_FILE, vocab_file);
  }
  explicit BertTokenizerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BertTokenizerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BertTokenizerOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BertTokenizerOptions> CreateBertTokenizerOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file = 0) {
  BertTokenizerOptionsBuilder builder_(_fbb);
  builder_.add_vocab_file(vocab_file);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BertTokenizerOptions> CreateBertTokenizerOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file = nullptr) {
  auto vocab_file__ = vocab_file ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*vocab_file) : 0;
  return tflite::CreateBertTokenizerOptions(
      _fbb,
      vocab_file__);
}

struct SentencePieceTokenizerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SentencePieceTokenizerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENTENCEPIECE_MODEL = 4,
    VT_VOCAB_FILE = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *sentencePiece_model() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_SENTENCEPIECE_MODEL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_VOCAB_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SENTENCEPIECE_MODEL) &&
           verifier.VerifyVector(sentencePiece_model()) &&
           verifier.VerifyVectorOfTables(sentencePiece_model()) &&
           VerifyOffset(verifier, VT_VOCAB_FILE) &&
           verifier.VerifyVector(vocab_file()) &&
           verifier.VerifyVectorOfTables(vocab_file()) &&
           verifier.EndTable();
  }
};

struct SentencePieceTokenizerOptionsBuilder {
  typedef SentencePieceTokenizerOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sentencePiece_model(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> sentencePiece_model) {
    fbb_.AddOffset(SentencePieceTokenizerOptions::VT_SENTENCEPIECE_MODEL, sentencePiece_model);
  }
  void add_vocab_file(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file) {
    fbb_.AddOffset(SentencePieceTokenizerOptions::VT_VOCAB_FILE, vocab_file);
  }
  explicit SentencePieceTokenizerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SentencePieceTokenizerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SentencePieceTokenizerOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SentencePieceTokenizerOptions> CreateSentencePieceTokenizerOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> sentencePiece_model = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file = 0) {
  SentencePieceTokenizerOptionsBuilder builder_(_fbb);
  builder_.add_vocab_file(vocab_file);
  builder_.add_sentencePiece_model(sentencePiece_model);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SentencePieceTokenizerOptions> CreateSentencePieceTokenizerOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *sentencePiece_model = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file = nullptr) {
  auto sentencePiece_model__ = sentencePiece_model ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*sentencePiece_model) : 0;
  auto vocab_file__ = vocab_file ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*vocab_file) : 0;
  return tflite::CreateSentencePieceTokenizerOptions(
      _fbb,
      sentencePiece_model__,
      vocab_file__);
}

struct RegexTokenizerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegexTokenizerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DELIM_REGEX_PATTERN = 4,
    VT_VOCAB_FILE = 6
  };
  const ::flatbuffers::String *delim_regex_pattern() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DELIM_REGEX_PATTERN);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_VOCAB_FILE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DELIM_REGEX_PATTERN) &&
           verifier.VerifyString(delim_regex_pattern()) &&
           VerifyOffset(verifier, VT_VOCAB_FILE) &&
           verifier.VerifyVector(vocab_file()) &&
           verifier.VerifyVectorOfTables(vocab_file()) &&
           verifier.EndTable();
  }
};

struct RegexTokenizerOptionsBuilder {
  typedef RegexTokenizerOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_delim_regex_pattern(::flatbuffers::Offset<::flatbuffers::String> delim_regex_pattern) {
    fbb_.AddOffset(RegexTokenizerOptions::VT_DELIM_REGEX_PATTERN, delim_regex_pattern);
  }
  void add_vocab_file(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file) {
    fbb_.AddOffset(RegexTokenizerOptions::VT_VOCAB_FILE, vocab_file);
  }
  explicit RegexTokenizerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegexTokenizerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegexTokenizerOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegexTokenizerOptions> CreateRegexTokenizerOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> delim_regex_pattern = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> vocab_file = 0) {
  RegexTokenizerOptionsBuilder builder_(_fbb);
  builder_.add_vocab_file(vocab_file);
  builder_.add_delim_regex_pattern(delim_regex_pattern);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegexTokenizerOptions> CreateRegexTokenizerOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *delim_regex_pattern = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *vocab_file = nullptr) {
  auto delim_regex_pattern__ = delim_regex_pattern ? _fbb.CreateString(delim_regex_pattern) : 0;
  auto vocab_file__ = vocab_file ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*vocab_file) : 0;
  return tflite::CreateRegexTokenizerOptions(
      _fbb,
      delim_regex_pattern__,
      vocab_file__);
}

struct ProcessUnit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIONS_TYPE = 4,
    VT_OPTIONS = 6
  };
  tflite::ProcessUnitOptions options_type() const {
    return static_cast<tflite::ProcessUnitOptions>(GetField<uint8_t>(VT_OPTIONS_TYPE, 0));
  }
  const void *options() const {
    return GetPointer<const void *>(VT_OPTIONS);
  }
  template<typename T> const T *options_as() const;
  const tflite::NormalizationOptions *options_as_NormalizationOptions() const {
    return options_type() == tflite::ProcessUnitOptions_NormalizationOptions ? static_cast<const tflite::NormalizationOptions *>(options()) : nullptr;
  }
  const tflite::ScoreCalibrationOptions *options_as_ScoreCalibrationOptions() const {
    return options_type() == tflite::ProcessUnitOptions_ScoreCalibrationOptions ? static_cast<const tflite::ScoreCalibrationOptions *>(options()) : nullptr;
  }
  const tflite::ScoreThresholdingOptions *options_as_ScoreThresholdingOptions() const {
    return options_type() == tflite::ProcessUnitOptions_ScoreThresholdingOptions ? static_cast<const tflite::ScoreThresholdingOptions *>(options()) : nullptr;
  }
  const tflite::BertTokenizerOptions *options_as_BertTokenizerOptions() const {
    return options_type() == tflite::ProcessUnitOptions_BertTokenizerOptions ? static_cast<const tflite::BertTokenizerOptions *>(options()) : nullptr;
  }
  const tflite::SentencePieceTokenizerOptions *options_as_SentencePieceTokenizerOptions() const {
    return options_type() == tflite::ProcessUnitOptions_SentencePieceTokenizerOptions ? static_cast<const tflite::SentencePieceTokenizerOptions *>(options()) : nullptr;
  }
  const tflite::RegexTokenizerOptions *options_as_RegexTokenizerOptions() const {
    return options_type() == tflite::ProcessUnitOptions_RegexTokenizerOptions ? static_cast<const tflite::RegexTokenizerOptions *>(options()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPTIONS_TYPE, 1) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           VerifyProcessUnitOptions(verifier, options(), options_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tflite::NormalizationOptions *ProcessUnit::options_as<tflite::NormalizationOptions>() const {
  return options_as_NormalizationOptions();
}

template<> inline const tflite::ScoreCalibrationOptions *ProcessUnit::options_as<tflite::ScoreCalibrationOptions>() const {
  return options_as_ScoreCalibrationOptions();
}

template<> inline const tflite::ScoreThresholdingOptions *ProcessUnit::options_as<tflite::ScoreThresholdingOptions>() const {
  return options_as_ScoreThresholdingOptions();
}

template<> inline const tflite::BertTokenizerOptions *ProcessUnit::options_as<tflite::BertTokenizerOptions>() const {
  return options_as_BertTokenizerOptions();
}

template<> inline const tflite::SentencePieceTokenizerOptions *ProcessUnit::options_as<tflite::SentencePieceTokenizerOptions>() const {
  return options_as_SentencePieceTokenizerOptions();
}

template<> inline const tflite::RegexTokenizerOptions *ProcessUnit::options_as<tflite::RegexTokenizerOptions>() const {
  return options_as_RegexTokenizerOptions();
}

struct ProcessUnitBuilder {
  typedef ProcessUnit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_options_type(tflite::ProcessUnitOptions options_type) {
    fbb_.AddElement<uint8_t>(ProcessUnit::VT_OPTIONS_TYPE, static_cast<uint8_t>(options_type), 0);
  }
  void add_options(::flatbuffers::Offset<void> options) {
    fbb_.AddOffset(ProcessUnit::VT_OPTIONS, options);
  }
  explicit ProcessUnitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessUnit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessUnit> CreateProcessUnit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ProcessUnitOptions options_type = tflite::ProcessUnitOptions_NONE,
    ::flatbuffers::Offset<void> options = 0) {
  ProcessUnitBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_options_type(options_type);
  return builder_.Finish();
}

struct Stats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  const ::flatbuffers::Vector<float> *max() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAX);
  }
  const ::flatbuffers::Vector<float> *min() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MIN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  typedef Stats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_max(::flatbuffers::Offset<::flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(Stats::VT_MAX, max);
  }
  void add_min(::flatbuffers::Offset<::flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(Stats::VT_MIN, min);
  }
  explicit StatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stats> CreateStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> max = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> min = 0) {
  StatsBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Stats> CreateStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *min = nullptr) {
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  return tflite::CreateStats(
      _fbb,
      max__,
      min__);
}

struct TensorGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TENSOR_NAMES = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tensor_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TENSOR_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TENSOR_NAMES) &&
           verifier.VerifyVector(tensor_names()) &&
           verifier.VerifyVectorOfStrings(tensor_names()) &&
           verifier.EndTable();
  }
};

struct TensorGroupBuilder {
  typedef TensorGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TensorGroup::VT_NAME, name);
  }
  void add_tensor_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensor_names) {
    fbb_.AddOffset(TensorGroup::VT_TENSOR_NAMES, tensor_names);
  }
  explicit TensorGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorGroup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorGroup> CreateTensorGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensor_names = 0) {
  TensorGroupBuilder builder_(_fbb);
  builder_.add_tensor_names(tensor_names);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorGroup> CreateTensorGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tensor_names = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tensor_names__ = tensor_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tensor_names) : 0;
  return tflite::CreateTensorGroup(
      _fbb,
      name__,
      tensor_names__);
}

struct TensorMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_DIMENSION_NAMES = 8,
    VT_CONTENT = 10,
    VT_PROCESS_UNITS = 12,
    VT_STATS = 14,
    VT_ASSOCIATED_FILES = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *dimension_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DIMENSION_NAMES);
  }
  const tflite::Content *content() const {
    return GetPointer<const tflite::Content *>(VT_CONTENT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *process_units() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *>(VT_PROCESS_UNITS);
  }
  const tflite::Stats *stats() const {
    return GetPointer<const tflite::Stats *>(VT_STATS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_ASSOCIATED_FILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_DIMENSION_NAMES) &&
           verifier.VerifyVector(dimension_names()) &&
           verifier.VerifyVectorOfStrings(dimension_names()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyTable(content()) &&
           VerifyOffset(verifier, VT_PROCESS_UNITS) &&
           verifier.VerifyVector(process_units()) &&
           verifier.VerifyVectorOfTables(process_units()) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyTable(stats()) &&
           VerifyOffset(verifier, VT_ASSOCIATED_FILES) &&
           verifier.VerifyVector(associated_files()) &&
           verifier.VerifyVectorOfTables(associated_files()) &&
           verifier.EndTable();
  }
};

struct TensorMetadataBuilder {
  typedef TensorMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TensorMetadata::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(TensorMetadata::VT_DESCRIPTION, description);
  }
  void add_dimension_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dimension_names) {
    fbb_.AddOffset(TensorMetadata::VT_DIMENSION_NAMES, dimension_names);
  }
  void add_content(::flatbuffers::Offset<tflite::Content> content) {
    fbb_.AddOffset(TensorMetadata::VT_CONTENT, content);
  }
  void add_process_units(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> process_units) {
    fbb_.AddOffset(TensorMetadata::VT_PROCESS_UNITS, process_units);
  }
  void add_stats(::flatbuffers::Offset<tflite::Stats> stats) {
    fbb_.AddOffset(TensorMetadata::VT_STATS, stats);
  }
  void add_associated_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files) {
    fbb_.AddOffset(TensorMetadata::VT_ASSOCIATED_FILES, associated_files);
  }
  explicit TensorMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorMetadata> CreateTensorMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dimension_names = 0,
    ::flatbuffers::Offset<tflite::Content> content = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> process_units = 0,
    ::flatbuffers::Offset<tflite::Stats> stats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files = 0) {
  TensorMetadataBuilder builder_(_fbb);
  builder_.add_associated_files(associated_files);
  builder_.add_stats(stats);
  builder_.add_process_units(process_units);
  builder_.add_content(content);
  builder_.add_dimension_names(dimension_names);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorMetadata> CreateTensorMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *dimension_names = nullptr,
    ::flatbuffers::Offset<tflite::Content> content = 0,
    const std::vector<::flatbuffers::Offset<tflite::ProcessUnit>> *process_units = nullptr,
    ::flatbuffers::Offset<tflite::Stats> stats = 0,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto dimension_names__ = dimension_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*dimension_names) : 0;
  auto process_units__ = process_units ? _fbb.CreateVector<::flatbuffers::Offset<tflite::ProcessUnit>>(*process_units) : 0;
  auto associated_files__ = associated_files ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*associated_files) : 0;
  return tflite::CreateTensorMetadata(
      _fbb,
      name__,
      description__,
      dimension_names__,
      content,
      process_units__,
      stats,
      associated_files__);
}

struct CustomMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CustomMetadataBuilder {
  typedef CustomMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CustomMetadata::VT_NAME, name);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(CustomMetadata::VT_DATA, data);
  }
  explicit CustomMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomMetadata> CreateCustomMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  CustomMetadataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomMetadata> CreateCustomMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::CreateCustomMetadata(
      _fbb,
      name__,
      data__);
}

struct SubGraphMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubGraphMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_INPUT_TENSOR_METADATA = 8,
    VT_OUTPUT_TENSOR_METADATA = 10,
    VT_ASSOCIATED_FILES = 12,
    VT_INPUT_PROCESS_UNITS = 14,
    VT_OUTPUT_PROCESS_UNITS = 16,
    VT_INPUT_TENSOR_GROUPS = 18,
    VT_OUTPUT_TENSOR_GROUPS = 20,
    VT_CUSTOM_METADATA = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>> *input_tensor_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>> *>(VT_INPUT_TENSOR_METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>> *output_tensor_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>> *>(VT_OUTPUT_TENSOR_METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_ASSOCIATED_FILES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *input_process_units() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *>(VT_INPUT_PROCESS_UNITS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *output_process_units() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>> *>(VT_OUTPUT_PROCESS_UNITS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>> *input_tensor_groups() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>> *>(VT_INPUT_TENSOR_GROUPS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>> *output_tensor_groups() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>> *>(VT_OUTPUT_TENSOR_GROUPS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::CustomMetadata>> *custom_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::CustomMetadata>> *>(VT_CUSTOM_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_INPUT_TENSOR_METADATA) &&
           verifier.VerifyVector(input_tensor_metadata()) &&
           verifier.VerifyVectorOfTables(input_tensor_metadata()) &&
           VerifyOffset(verifier, VT_OUTPUT_TENSOR_METADATA) &&
           verifier.VerifyVector(output_tensor_metadata()) &&
           verifier.VerifyVectorOfTables(output_tensor_metadata()) &&
           VerifyOffset(verifier, VT_ASSOCIATED_FILES) &&
           verifier.VerifyVector(associated_files()) &&
           verifier.VerifyVectorOfTables(associated_files()) &&
           VerifyOffset(verifier, VT_INPUT_PROCESS_UNITS) &&
           verifier.VerifyVector(input_process_units()) &&
           verifier.VerifyVectorOfTables(input_process_units()) &&
           VerifyOffset(verifier, VT_OUTPUT_PROCESS_UNITS) &&
           verifier.VerifyVector(output_process_units()) &&
           verifier.VerifyVectorOfTables(output_process_units()) &&
           VerifyOffset(verifier, VT_INPUT_TENSOR_GROUPS) &&
           verifier.VerifyVector(input_tensor_groups()) &&
           verifier.VerifyVectorOfTables(input_tensor_groups()) &&
           VerifyOffset(verifier, VT_OUTPUT_TENSOR_GROUPS) &&
           verifier.VerifyVector(output_tensor_groups()) &&
           verifier.VerifyVectorOfTables(output_tensor_groups()) &&
           VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
           verifier.VerifyVector(custom_metadata()) &&
           verifier.VerifyVectorOfTables(custom_metadata()) &&
           verifier.EndTable();
  }
};

struct SubGraphMetadataBuilder {
  typedef SubGraphMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SubGraphMetadata::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(SubGraphMetadata::VT_DESCRIPTION, description);
  }
  void add_input_tensor_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>>> input_tensor_metadata) {
    fbb_.AddOffset(SubGraphMetadata::VT_INPUT_TENSOR_METADATA, input_tensor_metadata);
  }
  void add_output_tensor_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>>> output_tensor_metadata) {
    fbb_.AddOffset(SubGraphMetadata::VT_OUTPUT_TENSOR_METADATA, output_tensor_metadata);
  }
  void add_associated_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files) {
    fbb_.AddOffset(SubGraphMetadata::VT_ASSOCIATED_FILES, associated_files);
  }
  void add_input_process_units(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> input_process_units) {
    fbb_.AddOffset(SubGraphMetadata::VT_INPUT_PROCESS_UNITS, input_process_units);
  }
  void add_output_process_units(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> output_process_units) {
    fbb_.AddOffset(SubGraphMetadata::VT_OUTPUT_PROCESS_UNITS, output_process_units);
  }
  void add_input_tensor_groups(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>>> input_tensor_groups) {
    fbb_.AddOffset(SubGraphMetadata::VT_INPUT_TENSOR_GROUPS, input_tensor_groups);
  }
  void add_output_tensor_groups(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>>> output_tensor_groups) {
    fbb_.AddOffset(SubGraphMetadata::VT_OUTPUT_TENSOR_GROUPS, output_tensor_groups);
  }
  void add_custom_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::CustomMetadata>>> custom_metadata) {
    fbb_.AddOffset(SubGraphMetadata::VT_CUSTOM_METADATA, custom_metadata);
  }
  explicit SubGraphMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraphMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraphMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraphMetadata> CreateSubGraphMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>>> input_tensor_metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMetadata>>> output_tensor_metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> input_process_units = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ProcessUnit>>> output_process_units = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>>> input_tensor_groups = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorGroup>>> output_tensor_groups = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::CustomMetadata>>> custom_metadata = 0) {
  SubGraphMetadataBuilder builder_(_fbb);
  builder_.add_custom_metadata(custom_metadata);
  builder_.add_output_tensor_groups(output_tensor_groups);
  builder_.add_input_tensor_groups(input_tensor_groups);
  builder_.add_output_process_units(output_process_units);
  builder_.add_input_process_units(input_process_units);
  builder_.add_associated_files(associated_files);
  builder_.add_output_tensor_metadata(output_tensor_metadata);
  builder_.add_input_tensor_metadata(input_tensor_metadata);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraphMetadata> CreateSubGraphMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::TensorMetadata>> *input_tensor_metadata = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::TensorMetadata>> *output_tensor_metadata = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::ProcessUnit>> *input_process_units = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::ProcessUnit>> *output_process_units = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::TensorGroup>> *input_tensor_groups = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::TensorGroup>> *output_tensor_groups = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::CustomMetadata>> *custom_metadata = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto input_tensor_metadata__ = input_tensor_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMetadata>>(*input_tensor_metadata) : 0;
  auto output_tensor_metadata__ = output_tensor_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMetadata>>(*output_tensor_metadata) : 0;
  auto associated_files__ = associated_files ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*associated_files) : 0;
  auto input_process_units__ = input_process_units ? _fbb.CreateVector<::flatbuffers::Offset<tflite::ProcessUnit>>(*input_process_units) : 0;
  auto output_process_units__ = output_process_units ? _fbb.CreateVector<::flatbuffers::Offset<tflite::ProcessUnit>>(*output_process_units) : 0;
  auto input_tensor_groups__ = input_tensor_groups ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorGroup>>(*input_tensor_groups) : 0;
  auto output_tensor_groups__ = output_tensor_groups ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorGroup>>(*output_tensor_groups) : 0;
  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::CustomMetadata>>(*custom_metadata) : 0;
  return tflite::CreateSubGraphMetadata(
      _fbb,
      name__,
      description__,
      input_tensor_metadata__,
      output_tensor_metadata__,
      associated_files__,
      input_process_units__,
      output_process_units__,
      input_tensor_groups__,
      output_tensor_groups__,
      custom_metadata__);
}

struct ModelMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VERSION = 8,
    VT_SUBGRAPH_METADATA = 10,
    VT_AUTHOR = 12,
    VT_LICENSE = 14,
    VT_ASSOCIATED_FILES = 16,
    VT_MIN_PARSER_VERSION = 18
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraphMetadata>> *subgraph_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraphMetadata>> *>(VT_SUBGRAPH_METADATA);
  }
  const ::flatbuffers::String *author() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTHOR);
  }
  const ::flatbuffers::String *license() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>> *>(VT_ASSOCIATED_FILES);
  }
  const ::flatbuffers::String *min_parser_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIN_PARSER_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_SUBGRAPH_METADATA) &&
           verifier.VerifyVector(subgraph_metadata()) &&
           verifier.VerifyVectorOfTables(subgraph_metadata()) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(author()) &&
           VerifyOffset(verifier, VT_LICENSE) &&
           verifier.VerifyString(license()) &&
           VerifyOffset(verifier, VT_ASSOCIATED_FILES) &&
           verifier.VerifyVector(associated_files()) &&
           verifier.VerifyVectorOfTables(associated_files()) &&
           VerifyOffset(verifier, VT_MIN_PARSER_VERSION) &&
           verifier.VerifyString(min_parser_version()) &&
           verifier.EndTable();
  }
};

struct ModelMetadataBuilder {
  typedef ModelMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ModelMetadata::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(ModelMetadata::VT_DESCRIPTION, description);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(ModelMetadata::VT_VERSION, version);
  }
  void add_subgraph_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraphMetadata>>> subgraph_metadata) {
    fbb_.AddOffset(ModelMetadata::VT_SUBGRAPH_METADATA, subgraph_metadata);
  }
  void add_author(::flatbuffers::Offset<::flatbuffers::String> author) {
    fbb_.AddOffset(ModelMetadata::VT_AUTHOR, author);
  }
  void add_license(::flatbuffers::Offset<::flatbuffers::String> license) {
    fbb_.AddOffset(ModelMetadata::VT_LICENSE, license);
  }
  void add_associated_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files) {
    fbb_.AddOffset(ModelMetadata::VT_ASSOCIATED_FILES, associated_files);
  }
  void add_min_parser_version(::flatbuffers::Offset<::flatbuffers::String> min_parser_version) {
    fbb_.AddOffset(ModelMetadata::VT_MIN_PARSER_VERSION, min_parser_version);
  }
  explicit ModelMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelMetadata> CreateModelMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraphMetadata>>> subgraph_metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> author = 0,
    ::flatbuffers::Offset<::flatbuffers::String> license = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::AssociatedFile>>> associated_files = 0,
    ::flatbuffers::Offset<::flatbuffers::String> min_parser_version = 0) {
  ModelMetadataBuilder builder_(_fbb);
  builder_.add_min_parser_version(min_parser_version);
  builder_.add_associated_files(associated_files);
  builder_.add_license(license);
  builder_.add_author(author);
  builder_.add_subgraph_metadata(subgraph_metadata);
  builder_.add_version(version);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelMetadata> CreateModelMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::SubGraphMetadata>> *subgraph_metadata = nullptr,
    const char *author = nullptr,
    const char *license = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::AssociatedFile>> *associated_files = nullptr,
    const char *min_parser_version = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto subgraph_metadata__ = subgraph_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SubGraphMetadata>>(*subgraph_metadata) : 0;
  auto author__ = author ? _fbb.CreateString(author) : 0;
  auto license__ = license ? _fbb.CreateString(license) : 0;
  auto associated_files__ = associated_files ? _fbb.CreateVector<::flatbuffers::Offset<tflite::AssociatedFile>>(*associated_files) : 0;
  auto min_parser_version__ = min_parser_version ? _fbb.CreateString(min_parser_version) : 0;
  return tflite::CreateModelMetadata(
      _fbb,
      name__,
      description__,
      version__,
      subgraph_metadata__,
      author__,
      license__,
      associated_files__,
      min_parser_version__);
}

inline bool VerifyContentProperties(::flatbuffers::Verifier &verifier, const void *obj, ContentProperties type) {
  switch (type) {
    case ContentProperties_NONE: {
      return true;
    }
    case ContentProperties_FeatureProperties: {
      auto ptr = reinterpret_cast<const tflite::FeatureProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ContentProperties_ImageProperties: {
      auto ptr = reinterpret_cast<const tflite::ImageProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ContentProperties_BoundingBoxProperties: {
      auto ptr = reinterpret_cast<const tflite::BoundingBoxProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ContentProperties_AudioProperties: {
      auto ptr = reinterpret_cast<const tflite::AudioProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyContentPropertiesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyContentProperties(
        verifier,  values->Get(i), types->GetEnum<ContentProperties>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyProcessUnitOptions(::flatbuffers::Verifier &verifier, const void *obj, ProcessUnitOptions type) {
  switch (type) {
    case ProcessUnitOptions_NONE: {
      return true;
    }
    case ProcessUnitOptions_NormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::NormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProcessUnitOptions_ScoreCalibrationOptions: {
      auto ptr = reinterpret_cast<const tflite::ScoreCalibrationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProcessUnitOptions_ScoreThresholdingOptions: {
      auto ptr = reinterpret_cast<const tflite::ScoreThresholdingOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProcessUnitOptions_BertTokenizerOptions: {
      auto ptr = reinterpret_cast<const tflite::BertTokenizerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProcessUnitOptions_SentencePieceTokenizerOptions: {
      auto ptr = reinterpret_cast<const tflite::SentencePieceTokenizerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProcessUnitOptions_RegexTokenizerOptions: {
      auto ptr = reinterpret_cast<const tflite::RegexTokenizerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyProcessUnitOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyProcessUnitOptions(
        verifier,  values->Get(i), types->GetEnum<ProcessUnitOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline const tflite::ModelMetadata *GetModelMetadata(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::ModelMetadata>(buf);
}

inline const tflite::ModelMetadata *GetSizePrefixedModelMetadata(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::ModelMetadata>(buf);
}

inline const char *ModelMetadataIdentifier() {
  return "M001";
}

inline bool ModelMetadataBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelMetadataIdentifier());
}

inline bool SizePrefixedModelMetadataBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelMetadataIdentifier(), true);
}

inline bool VerifyModelMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::ModelMetadata>(ModelMetadataIdentifier());
}

inline bool VerifySizePrefixedModelMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::ModelMetadata>(ModelMetadataIdentifier());
}

inline const char *ModelMetadataExtension() {
  return "tflitemeta";
}

inline void FinishModelMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::ModelMetadata> root) {
  fbb.Finish(root, ModelMetadataIdentifier());
}

inline void FinishSizePrefixedModelMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::ModelMetadata> root) {
  fbb.FinishSizePrefixed(root, ModelMetadataIdentifier());
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_METADATASCHEMA_TFLITE_H_
